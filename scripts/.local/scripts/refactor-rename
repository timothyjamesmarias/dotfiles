#!/usr/bin/env bash

# refactor-rename - Safe text-based symbol renaming across a project
# Uses ripgrep for finding and sed for replacing with word-boundary safety

set -e

# Colors
CYAN='\033[0;36m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
RED='\033[0;31m'
BLUE='\033[0;34m'
RESET='\033[0m'

# Configuration
PREVIEW_CONTEXT=3  # lines of context in preview

usage() {
  cat << EOF
${CYAN}refactor-rename${RESET} - Safe text-based symbol renaming

${YELLOW}Usage:${RESET}
  refactor-rename <old-name> <new-name> [options]
  refactor-rename --interactive

${YELLOW}Options:${RESET}
  -i, --interactive       Interactive mode - select old/new names via prompts
  -p, --path <path>       Limit search to specific path (default: .)
  -t, --type <type>       Limit to file type (e.g., js, py, rb, php, c)
  -g, --glob <pattern>    Limit to glob pattern (e.g., "*.js", "src/**/*.rb")
  --no-word-boundary      Disable word boundary matching (replace anywhere)
  --preview-only          Show preview without applying changes
  --case-sensitive        Case-sensitive matching (default: smart case)
  -h, --help              Show this help

${YELLOW}Examples:${RESET}
  refactor-rename getUserData fetchUserData
  refactor-rename old_func new_func --type rb
  refactor-rename FooBar BazQux --glob "src/**/*.ts"
  refactor-rename --interactive

${YELLOW}Features:${RESET}
  • Word boundary matching by default (won't replace partial matches)
  • Interactive file selection with preview
  • Safe replacement with backup option
  • Smart case matching (case-insensitive unless uppercase is used)
  • Multi-language support via ripgrep
EOF
  exit 0
}

# Parse arguments
INTERACTIVE=0
OLD_NAME=""
NEW_NAME=""
SEARCH_PATH="."
FILE_TYPE=""
GLOB_PATTERN=""
WORD_BOUNDARY=1
PREVIEW_ONLY=0
CASE_SENSITIVE=0

while [[ $# -gt 0 ]]; do
  case $1 in
    -h|--help)
      usage
      ;;
    -i|--interactive)
      INTERACTIVE=1
      shift
      ;;
    -p|--path)
      SEARCH_PATH="$2"
      shift 2
      ;;
    -t|--type)
      FILE_TYPE="$2"
      shift 2
      ;;
    -g|--glob)
      GLOB_PATTERN="$2"
      shift 2
      ;;
    --no-word-boundary)
      WORD_BOUNDARY=0
      shift
      ;;
    --preview-only)
      PREVIEW_ONLY=1
      shift
      ;;
    --case-sensitive)
      CASE_SENSITIVE=1
      shift
      ;;
    -*)
      echo -e "${RED}Error: Unknown option: $1${RESET}"
      echo "Use --help for usage information"
      exit 1
      ;;
    *)
      if [ -z "$OLD_NAME" ]; then
        OLD_NAME="$1"
      elif [ -z "$NEW_NAME" ]; then
        NEW_NAME="$1"
      else
        echo -e "${RED}Error: Too many arguments${RESET}"
        exit 1
      fi
      shift
      ;;
  esac
done

# Interactive mode
if [ $INTERACTIVE -eq 1 ]; then
  echo -e "${CYAN}Interactive Rename Mode${RESET}"
  echo ""
  read -p "$(echo -e ${YELLOW}Enter old name:${RESET} )" OLD_NAME
  read -p "$(echo -e ${YELLOW}Enter new name:${RESET} )" NEW_NAME
fi

# Validate input
if [ -z "$OLD_NAME" ] || [ -z "$NEW_NAME" ]; then
  echo -e "${RED}Error: Both old and new names are required${RESET}"
  echo "Use --help for usage information"
  exit 1
fi

if [ "$OLD_NAME" = "$NEW_NAME" ]; then
  echo -e "${RED}Error: Old and new names are identical${RESET}"
  exit 1
fi

# Build ripgrep command
RG_ARGS=(
  "--line-number"
  "--no-heading"
  "--color=always"
  "--hidden"
  "--glob=!.git"
  "--glob=!node_modules"
  "--glob=!target"
  "--glob=!dist"
  "--glob=!build"
)

# Add case sensitivity
if [ $CASE_SENSITIVE -eq 0 ]; then
  RG_ARGS+=("--smart-case")
else
  RG_ARGS+=("--case-sensitive")
fi

# Add file type or glob
if [ -n "$FILE_TYPE" ]; then
  RG_ARGS+=("--type=$FILE_TYPE")
elif [ -n "$GLOB_PATTERN" ]; then
  RG_ARGS+=("--glob=$GLOB_PATTERN")
fi

# Build search pattern with word boundaries
if [ $WORD_BOUNDARY -eq 1 ]; then
  SEARCH_PATTERN="\b${OLD_NAME}\b"
else
  SEARCH_PATTERN="$OLD_NAME"
fi

# Search for occurrences
echo -e "${CYAN}Searching for '${OLD_NAME}'...${RESET}"
echo ""

TEMP_RESULTS=$(mktemp)
if ! rg "${RG_ARGS[@]}" "$SEARCH_PATTERN" "$SEARCH_PATH" > "$TEMP_RESULTS" 2>/dev/null; then
  echo -e "${YELLOW}No occurrences found${RESET}"
  rm -f "$TEMP_RESULTS"
  exit 0
fi

# Count total matches and files
TOTAL_MATCHES=$(wc -l < "$TEMP_RESULTS" | tr -d ' ')
TOTAL_FILES=$(cut -d: -f1 "$TEMP_RESULTS" | sort -u | wc -l | tr -d ' ')

echo -e "${GREEN}Found ${TOTAL_MATCHES} occurrence(s) in ${TOTAL_FILES} file(s)${RESET}"
echo ""

# Show preview function for fzf
preview_replacement() {
  local file_line="$1"
  local file=$(echo "$file_line" | cut -d: -f1)
  local line_num=$(echo "$file_line" | cut -d: -f2)

  echo -e "${CYAN}File: ${file}:${line_num}${RESET}"
  echo ""

  # Show context with highlighted line
  if command -v bat >/dev/null 2>&1; then
    bat --style=numbers --color=always --highlight-line "$line_num" \
      --line-range "$((line_num - PREVIEW_CONTEXT)):$((line_num + PREVIEW_CONTEXT))" \
      "$file" 2>/dev/null || cat "$file"
  else
    # Fallback to grep with context
    grep -n -C "$PREVIEW_CONTEXT" ".*" "$file" | grep -A "$PREVIEW_CONTEXT" -B "$PREVIEW_CONTEXT" "^${line_num}:"
  fi

  echo ""
  echo -e "${YELLOW}Will replace:${RESET} ${OLD_NAME}"
  echo -e "${GREEN}With:${RESET}         ${NEW_NAME}"
}

export -f preview_replacement
export CYAN GREEN YELLOW RED BLUE RESET OLD_NAME NEW_NAME PREVIEW_CONTEXT

# Let user select which files to modify
echo -e "${YELLOW}Select files to modify (use TAB for multi-select, ENTER to confirm):${RESET}"
echo ""

SELECTED_FILES=$(cut -d: -f1 "$TEMP_RESULTS" | sort -u | \
  fzf --ansi \
      --multi \
      --height=80% \
      --layout=reverse \
      --border \
      --prompt="Files to modify > " \
      --preview 'bash -c "preview_replacement $(grep \"^{}:\" '"$TEMP_RESULTS"' | head -1)"' \
      --preview-window=right:60%:wrap \
      --header="TAB: select, ENTER: confirm, ESC: cancel")

rm -f "$TEMP_RESULTS"

# Check if user cancelled
if [ -z "$SELECTED_FILES" ]; then
  echo -e "${YELLOW}Cancelled by user${RESET}"
  exit 0
fi

# Count selected files
SELECTED_COUNT=$(echo "$SELECTED_FILES" | wc -l | tr -d ' ')
echo ""
echo -e "${GREEN}Selected ${SELECTED_COUNT} file(s) for modification${RESET}"
echo ""

# Show what will be changed
echo -e "${CYAN}Files to be modified:${RESET}"
echo "$SELECTED_FILES" | while read -r file; do
  MATCHES=$(rg "${RG_ARGS[@]}" "$SEARCH_PATTERN" "$file" 2>/dev/null | wc -l | tr -d ' ')
  echo -e "  ${BLUE}${file}${RESET} (${MATCHES} occurrence(s))"
done
echo ""

# Preview mode - just show what would be changed
if [ $PREVIEW_ONLY -eq 1 ]; then
  echo -e "${CYAN}Preview mode - showing changes without applying:${RESET}"
  echo ""

  echo "$SELECTED_FILES" | while read -r file; do
    echo -e "${BLUE}=== ${file} ===${RESET}"

    # Build sed pattern
    if [ $WORD_BOUNDARY -eq 1 ]; then
      SED_PATTERN="s/\b${OLD_NAME}\b/${NEW_NAME}/g"
    else
      SED_PATTERN="s/${OLD_NAME}/${NEW_NAME}/g"
    fi

    # Show diff-like output
    if command -v diff >/dev/null 2>&1; then
      diff -u "$file" <(sed "$SED_PATTERN" "$file") || true
    else
      sed "$SED_PATTERN" "$file"
    fi
    echo ""
  done

  exit 0
fi

# Confirm before applying
echo -e -n "${YELLOW}Apply these changes? (y/N): ${RESET}"
read -r CONFIRM

if [[ ! "$CONFIRM" =~ ^[Yy]$ ]]; then
  echo -e "${YELLOW}Cancelled by user${RESET}"
  exit 0
fi

# Apply changes
echo ""
echo -e "${CYAN}Applying changes...${RESET}"

# Build sed pattern
if [ $WORD_BOUNDARY -eq 1 ]; then
  SED_PATTERN="s/\b${OLD_NAME}\b/${NEW_NAME}/g"
else
  SED_PATTERN="s/${OLD_NAME}/${NEW_NAME}/g"
fi

SUCCESS_COUNT=0
FAILED_COUNT=0

echo "$SELECTED_FILES" | while read -r file; do
  # Create backup
  cp "$file" "${file}.bak"

  # Apply replacement
  if sed -i '' "$SED_PATTERN" "$file" 2>/dev/null; then
    echo -e "  ${GREEN}✓${RESET} ${file}"
    SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
    rm -f "${file}.bak"
  else
    echo -e "  ${RED}✗${RESET} ${file} (restored from backup)"
    mv "${file}.bak" "$file"
    FAILED_COUNT=$((FAILED_COUNT + 1))
  fi
done

echo ""
if [ $FAILED_COUNT -eq 0 ]; then
  echo -e "${GREEN}Successfully renamed '${OLD_NAME}' → '${NEW_NAME}' in ${SELECTED_COUNT} file(s)${RESET}"
else
  echo -e "${YELLOW}Completed with errors: ${SUCCESS_COUNT} succeeded, ${FAILED_COUNT} failed${RESET}"
fi
