#!/usr/bin/env bash

# cmd-finder - Fuzzy search through all zsh aliases, functions, and commands
# Prints the selected command to terminal for execution

# Configuration
ZSHCONFIG="${ZSHCONFIG:-$HOME/.config/zsh}"
CACHE_DIR="${XDG_CACHE_HOME:-$HOME/.cache}"
CACHE_FILE="$CACHE_DIR/cmd-finder-index"
TEMP_FILE=$(mktemp)

# Ensure cache directory exists
mkdir -p "$CACHE_DIR"

# List of source files to track
SOURCE_FILES=(
  "$ZSHCONFIG/aliases.zsh"
  "$ZSHCONFIG/files.zsh"
  "$ZSHCONFIG/git.zsh"
  "$ZSHCONFIG/utils.zsh"
  "$ZSHCONFIG/kotlin.zsh"
  "$ZSHCONFIG/kotlin-project-cli.zsh"
  "$ZSHCONFIG/docker.zsh"
  "$ZSHCONFIG/heroku.zsh"
  "$ZSHCONFIG/ctags.zsh"
  "$HOME/dotfiles/nvim/.config/nvim/lua/tim/remap.lua"
  "$HOME/dotfiles/tmux/.tmux.conf"
)

# Colors for output
CYAN='\033[0;36m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
RESET='\033[0m'

# Function to get modification time of a file
get_mtime() {
  local file="$1"
  if [ -f "$file" ]; then
    stat -f %m "$file" 2>/dev/null || stat -c %Y "$file" 2>/dev/null
  else
    echo "0"
  fi
}

# Function to check if cache is valid
is_cache_valid() {
  [ ! -f "$CACHE_FILE" ] && return 1

  # Compare each source file's current mtime with cached mtime
  for file in "${SOURCE_FILES[@]}"; do
    local current_mtime=$(get_mtime "$file")

    # Look for this file's mtime in the cache header
    local cached_mtime=$(grep "^# $file:" "$CACHE_FILE" 2>/dev/null | cut -d: -f2)

    # If file is newer or wasn't in cache, cache is invalid
    if [ "$current_mtime" != "$cached_mtime" ]; then
      return 1
    fi
  done

  return 0
}

# Function to build the cache
build_cache() {
  local temp_cache=$(mktemp)

  # Write metadata header with file mtimes
  echo "# cmd-finder cache - do not edit manually" > "$temp_cache"
  for file in "${SOURCE_FILES[@]}"; do
    local mtime=$(get_mtime "$file")
    echo "# $file:$mtime" >> "$temp_cache"
  done

  # Extract all commands and append to cache
  {
    # Extract from all zsh config files
    if [ -d "$ZSHCONFIG" ]; then
      extract_aliases "$ZSHCONFIG/aliases.zsh" "alias"
      extract_aliases "$ZSHCONFIG/files.zsh" "files"
      extract_aliases "$ZSHCONFIG/git.zsh" "git"
      extract_aliases "$ZSHCONFIG/utils.zsh" "utils"
      extract_aliases "$ZSHCONFIG/kotlin.zsh" "kotlin"
      extract_aliases "$ZSHCONFIG/kotlin-project-cli.zsh" "kt"
      extract_aliases "$ZSHCONFIG/docker.zsh" "docker"
      extract_aliases "$ZSHCONFIG/heroku.zsh" "heroku"

      extract_functions "$ZSHCONFIG/files.zsh" "files"
      extract_functions "$ZSHCONFIG/git.zsh" "git"
      extract_functions "$ZSHCONFIG/utils.zsh" "utils"
      extract_functions "$ZSHCONFIG/kotlin.zsh" "kotlin"
      extract_functions "$ZSHCONFIG/kotlin-project-cli.zsh" "kt"
      extract_functions "$ZSHCONFIG/docker.zsh" "docker"
    fi

    # Extract vim keymaps
    extract_vim_keymaps

    # Extract git config aliases
    extract_git_config_aliases

    # Extract tmux bindings
    extract_tmux_bindings
  } >> "$temp_cache"

  # Move temp cache to final location
  mv "$temp_cache" "$CACHE_FILE"
}

# Function to extract aliases from a file
extract_aliases() {
  local file="$1"
  local category="$2"

  grep -E "^alias [a-zA-Z0-9_-]+=" "$file" 2>/dev/null | while IFS= read -r line; do
    local name=$(echo "$line" | sed -E "s/^alias ([^=]+)=.*/\1/")
    local cmd=$(echo "$line" | sed -E "s/^alias [^=]+=(['\"]?)(.+)\1$/\2/" | sed "s/^'//" | sed "s/'$//")
    echo -e "${category}\t${name}\t${cmd}"
  done
}

# Function to extract functions from a file
extract_functions() {
  local file="$1"
  local category="$2"

  # Match function definitions: name() { ... } or function name { ... }
  grep -E "^[a-zA-Z0-9_-]+\(\)|^function [a-zA-Z0-9_-]+" "$file" 2>/dev/null | while IFS= read -r line; do
    local name=$(echo "$line" | sed -E "s/^function ([a-zA-Z0-9_-]+).*/\1/" | sed -E "s/^([a-zA-Z0-9_-]+)\(\).*/\1/")

    # Try to extract a brief description from comments above the function
    local linenum=$(grep -n "^${name}()\|^function ${name}" "$file" | head -1 | cut -d: -f1)
    local desc=""

    if [ -n "$linenum" ]; then
      # Look for comment on previous line
      desc=$(sed -n "$((linenum-1))p" "$file" | grep -E "^#" | sed 's/^# *//' | sed 's/^--- *//' || echo "function")
    fi

    [ -z "$desc" ] && desc="function"
    echo -e "${category}\t${name}\t${desc}"
  done
}

# Extract vim keybindings from remap.lua
extract_vim_keymaps() {
  local file="$HOME/dotfiles/nvim/.config/nvim/lua/tim/remap.lua"

  if [ ! -f "$file" ]; then
    return
  fi

  # Parse vim.keymap.set lines - extract key and description
  grep -E 'vim\.keymap\.set\(' "$file" | \
    perl -ne 'if (/keymap\.set\([^,]+,\s*"([^"]+)".*desc\s*=\s*"([^"]+)"/) {
      $key = $1;
      $desc = $2;
      $key =~ s/<leader>/ /g;  # Convert <leader> to space for readability
      print "vim\t$key\t$desc\n"
    }'
}

# Extract git aliases from gitconfig
extract_git_config_aliases() {
  git config --get-regexp '^alias\.' 2>/dev/null | \
    sed 's/^alias\.//' | \
    awk '{cmd=$1; $1=""; desc=$0; gsub(/^[ \t]+/, "", desc); print "git-cfg\t" cmd "\t" desc}'
}

# Extract tmux keybindings
extract_tmux_bindings() {
  local file="$HOME/dotfiles/tmux/.tmux.conf"

  if [ ! -f "$file" ]; then
    return
  fi

  grep -E '^bind' "$file" | \
    perl -ne 'if (/bind(?:-key)?\s+(?:-\w+\s+)*(\S+)\s+(.+)/) {
      $key = $1;
      $cmd = $2;
      $cmd =~ s/#.*//;  # Remove comments
      $cmd =~ s/^\s+|\s+$//g;  # Trim whitespace
      $cmd =~ s/^(split-window|send-keys|run-shell|new-window)\s+/\1: /;  # Format common commands
      print "tmux\t$key\t$cmd\n" if $cmd;
    }'
}

# Check for --rebuild flag
if [ "$1" = "--rebuild" ]; then
  build_cache
  echo "Cache rebuilt at $CACHE_FILE" >&2
  exit 0
fi

# Build or use cache
if ! is_cache_valid; then
  build_cache
fi

# Load data from cache (skip header lines starting with #)
grep -v '^#' "$CACHE_FILE" > "$TEMP_FILE"

# Function to show implementation preview
show_preview() {
  local category="$1"
  local name="$2"
  local desc="$3"

  echo -e "${CYAN}Category:${RESET} $category"
  echo -e "${GREEN}Command:${RESET}  $name"
  echo -e "${YELLOW}Details:${RESET}  $desc"
  echo ""

  # Show implementation based on category
  case "$category" in
    vim)
      # Show vim keymap implementation
      local search_key=$(echo "$name" | sed 's/ /<leader>/g')
      grep -A3 "\"$search_key\"" "$HOME/dotfiles/nvim/.config/nvim/lua/tim/remap.lua" 2>/dev/null | head -5
      ;;
    git|files|utils|alias|kotlin|docker)
      # Show zsh function or alias definition
      type "$name" 2>/dev/null || echo "(shell function/alias)"
      ;;
    git-cfg)
      # Show git config alias
      git config --get "alias.$name" 2>/dev/null
      ;;
    kt)
      # Show kt CLI command or alias
      type "$name" 2>/dev/null || echo "(kt CLI command - see: kt --help)"
      ;;
    tmux)
      # Show tmux binding
      grep "^bind.*$name" "$HOME/dotfiles/tmux/.tmux.conf" 2>/dev/null
      ;;
  esac
}

export -f show_preview
export CYAN GREEN YELLOW RESET

# Use fzf to select a command with enhanced preview
selected=$(cat "$TEMP_FILE" | \
  awk -F'\t' '{printf "%-12s %-20s %s\n", $1, $2, $3}' | \
  fzf --ansi \
      --height=80% \
      --layout=reverse \
      --border \
      --prompt="âš¡ Command > " \
      --preview-window=down:8:wrap \
      --preview 'bash -c "show_preview {1} {2} {3..}"' \
      --header="Search commands/aliases/keymaps (Ctrl-Y to copy, Ctrl-C to cancel)" \
      --bind='ctrl-y:execute-silent(echo -n {2} | pbcopy)+abort')

# Clean up temp file
rm -f "$TEMP_FILE"

# If something was selected, extract the command name and print it
if [ -n "$selected" ]; then
  # Extract just the command name (second column)
  cmd=$(echo "$selected" | awk '{print $2}')

  # Print the command to stdout (will be captured by zsh widget)
  echo -n "$cmd"
fi
